---
title: "Project 1 - Redwood Data Report"
author:
- Yue Li
- Tianyu Wu
date: "2022/10/13"
output:
  pdf_document
fontsize: 11pt
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  warning = FALSE,
  message = FALSE
  )
```

```{r}
library(tidyverse)
library(ggplot2)
library(dplyr)
library(gridExtra)
library(ggfortify)
library(cluster)
library(mixtools)
library(lubridate)
library(reshape2)
library(scales)
```

# 1. Data Collection

(a) The paper studies the spatial and temporal dynamics of the microclimate surrounding a coastal redwood tree at different level heights. The paper considers temperature, relative humidity, and sunlight levels (measured by \texttt{incident PAR} and \texttt{reflected PAR}) as the primary factors for characterizing microclimate variations of the redwood tree. Data was collected for a period of 44 days on a 70-meter tall redwood tree. The team uses the "macroscopic" wireless sensor network by putting sensor nodes packaged in weather chambers on different sections of tree with variation in height, angular location and radial distance. This study improves the variation details of the above factors on temporal scale, since previous studies only showed that there are variations across spatial scale but not on temporal scale. The group collected data after the 44-day experiment period and analyzed the performance of the sensor network on capturing temporal trends of data to improve accuracy of future sensor deployment. 

Here are some impacts we obtained from the paper on the sensor deployment:

The small variations in sensor positions (\texttt{height}) might lead to large differences in data collected, provided that the sensors are small enough and the phenomenon gets directional enough. As can be seen in the patterns of PAR data versus time, the data readings fluctuate according the sun's movement due to the belief that the wind moved the foliage and blocked sunlight access to the nodes. However, as can be seen in Figure 8, the patterns are actually consistent on different days. This contrast suggests that different orientations for each sensor result in different fluctuation patterns. The noisy data was a response from a highly-focused sensor.

To record the long-term performance of the sensor network for capturing data, network management is crucial. The paper suggests that one should include a network monitoring component that can evaluate the performance of the network timely and can report abnormalities. In the current study, the local logs ran out of space for data storage during the data collection period and led to network failure. Therefore, the network can serve as a way to detect and compensate for failures in logging. The logging can compensate for failures in the network.

The study explored the existence of spatial gradients in the microclimate and collected sufficient to see the variation of the gradients with respect to time. One can make use of the data for validating biological theories. Plant biologists can build a model of the effect of microclimate gradients on the sap flow rate to visualize the rate of sap flow varies over time with respect to humidity, temperature and PAR.

(b) Before deploying the sensors on the tree, the study performed roof and chamber calibration checks. The calibration process evaluates performance data on different subsets of the sensors. Roof calibration establishes that PAR sensors are producing acceptable findings. Chamber calibration is a two-point calibration process to obtain responses of temperature and humidity. 

The deployment package protects the electronics from the weather and safely exposes the sensors. All sensored are sampled every 5 minutes during one month in early summer, containing the most dynamic microclimatic variation. The nodes are placed on the west side of the tree. The nodes are placed 15 meters to 70 meters above ground level, with about 2-meter spacing between nodes, and at a radial distance of 0.1-1.0 meter from the trunk. Meanwhile, some nodes are placed out of the default angular and radial ranges to measure the microclimate nearby. 

For data storage and management, the study included a local data logging system. The logger recorded readings taken by the queries before passing to multi-hop routing layer and stopped recording when the flash chip is full. The complete data logger was deployed  since the capacity of the flash was sufficient for the duration of the data collection process.

The study first measures traditional climate variables: temperature, humidity and light levels. Temperature and humidity are parts of the transpiration model. The two variables connected sunlight levels are incident PAR and reflected PAR. Incident PAR quantifies the energy available for photosynthesis. In the dataset, these variable are: humidity (\texttt{humidity}), temperature (\texttt{humid temp}) and PAR measured on the top and at the bottom of the sensor (\texttt{hamatop} and \texttt{hamabot} respectively). \texttt{sonoma-data-log} dataset consists of data stored locally during the data collection process. \texttt{sonoma-data-net} constitutes data transmitted to the database during the data collection process. \texttt{mote-location-data} records the height, direction, radial distance and relative location to tree of the sensors. This dataset can help us analyze the temporal and spatial effect of the climate variables. \texttt{sonoma-dates} matches the epochs with the correct times. 

# 2. Data Cleaning

```{r}
log_data <- read_csv("RedwoodData/sonoma-data-log.csv")
net_data <- read_csv("RedwoodData/sonoma-data-net.csv")
loc_data <- read.table("RedwoodData/mote-location-data.txt", header = T, sep = "")
date0 = read.delim("RedwoodData/sonoma-dates", header = F)
# epochNums
epochNums = substring(date0[1,1], 14, nchar(date0[1,1])-3)
epochNums = strsplit(epochNums, " ")
epochNums = as.numeric(unlist(epochNums))
# epochDates
epochDates = substring(date0[2,1], 16, nchar(date0[2,1])-4)
epochDates = strsplit(epochDates, "\' \'")
epochDates = as.POSIXlt(unlist(epochDates), format = "%a %b  %d %H:%M:%S %Y")
# epochDays
epochDays = substring(date0[3,1], 14, nchar(date0[3,1])-3)
epochDays = strsplit(epochDays, " ")
epochDays = as.numeric(unlist(epochDays))
# create the new data frame
new_date0 = data.frame(epochNums, epochDates, epochDays)
colnames(new_date0)[1] = "epoch"
colnames(new_date0)[2] = "result_time"
colnames(new_date0)[3] = "result_days"
```

```{r}
# standardized result_time by epoch
log_data <- merge(log_data, new_date0, by = "epoch") %>%
  mutate(result_time = result_time.y) %>%
  select(-result_days, -ends_with(".x"), -ends_with(".y"))

net_data <- merge(net_data, new_date0, by = "epoch") %>%
  mutate(result_time = result_time.y) %>%
  select(-result_days, -ends_with(".x"), -ends_with(".y"))
```

(a) Variable voltage for two datasets are not in the same domain.

```{r, fig.cap="Raw voltage histogram", fig.width=6, fig.height=2}
plot1 <- log_data %>%
           ggplot(aes(x = voltage)) +
           geom_histogram(na.rm = T, bins = 50) +
           labs(x = "Voltage", y = "Count", title = "Log Dataset") +
           theme_bw()

plot2 <- net_data %>%
           ggplot(aes(x = voltage)) +
           geom_histogram(na.rm = T, bins = 50) +
           labs(x = "Voltage", y = "Count", title = "Net Dataset") +
           theme_bw()

grid.arrange(plot1, plot2, ncol = 2)
```

We know from the paper that the incident and reflected PAR measurements were collected by two Hamamatsu S1087 photodiodes interfaced to the 10-bit ADC on Mica2Dot. From user manual (http://www-db.ics.uci.edu/pages/research/quasar/MPR-MIB%20Series%20User%20Manual%207430-0021-06_A.pdf Page 25) we found the formula of conversion to be $V_{batt} = V_{ref} \times ADC\_FS / ADC\_Count$. The voltage data from net dataset is converted to the right range after the conversion.

```{r}
# standardize voltage
ADC_FS = 1024
V_ref = 0.6 
net_data <- net_data %>%
  mutate(voltage = V_ref * ADC_FS / voltage)
```

(b) It turns out that when a row contains any missing values, all four variables of interests are missing. Missing values are found in between 2004-04-30 and 2004-05-25 (27 days) for \texttt{log-dataset} and in between 2004-05-07 and 2004-05-29 (22 days) for \texttt{net dataset}. These two time period almost span the entire experiment. Most of the time there is only one record with missing value for each epoch, which indicates that most of the time only one single node is not working well. In the end, 8270 rows of missing values are dropped from \texttt{log dataset} and 4262 rows are dropped from \texttt{net dataset}.

```{r, fig.cap="Count of NAs for each epoch", fig.width=6, fig.height=2}
log_data_na <- log_data[rowSums(is.na(log_data)) > 0,]
plot1 <- log_data_na %>%
  select(result_time) %>%
  ggplot(aes(x = result_time)) +
  geom_bar() +
  labs(x = "Date", y = "Count of NAs", title = "Log Dataset") +
  theme_bw()

net_data_na <- net_data[rowSums(is.na(net_data)) > 0,]
plot2 <- net_data_na %>%
  select(result_time) %>%
  ggplot(aes(x = result_time)) +
  geom_bar() +
  labs(x = "Date", y = "Count of NAs", title = "Net Dataset") +
  theme_bw()

grid.arrange(plot1, plot2, ncol = 2)
```

```{r}
# NA drop
log_data <- log_data %>% drop_na()
net_data <- net_data %>% drop_na()
```

(c) First, we combine log data and net data together. The general strategy is outer join to keep as much data as possible. Given the fact that time span of log dataset covers that of net dataset and net dataset has more data records, we decide that when both dataset contain the same data record, we keep the one inside net dataset. The next step is the inner join with location dataset. After joining there are 327228/333319 rows remaining.

```{r}
# combine log and net data
outer <- merge(x = net_data, y = log_data, by = c("nodeid", "epoch"), all = T)
data_all <- outer %>% 
  mutate( humidity = case_when(!is.na(humidity.x) ~ humidity.x,
                      TRUE ~ humidity.y),
          humid_temp = case_when(!is.na(humid_temp.x) ~ humid_temp.x,
                              TRUE ~ humid_temp.y),
          hamatop = case_when(!is.na(hamatop.x) ~ hamatop.x,
                              TRUE ~ hamatop.y),
          hamabot = case_when(!is.na(hamabot.x) ~ hamabot.x,
                              TRUE ~ hamabot.y),
          voltage = case_when(!is.na(voltage.x) ~ voltage.x,
                              TRUE ~ voltage.y),
          result_time = case_when(!is.na(result_time.x) ~ result_time.x,
                              TRUE ~ result_time.y),
          depth = case_when(!is.na(depth.x) ~ depth.x,
                              TRUE ~ depth.y),
          parent = case_when(!is.na(parent.x) ~ parent.x,
                                            TRUE ~ parent.y)) %>%
  select(-ends_with('.x'), -ends_with('.y'))
```

```{r}
# incorporate location data
data_all <- merge(data_all, loc_data, by.x = "nodeid", by.y = "ID") %>%
  rename(height = Height,
         direc = Direc,
         dist = Dist,
         tree = Tree)
```

(d) First we extract some nodes with abnormal readings and verified the finding in the thesis that abnormal readings are correlated with abnormal voltage.

```{r, fig.cap="correlation between abnormal readings and low voltage", fig.width=8, fig.height=5}
plot1 <- data_all %>%
  filter(nodeid == 78 | nodeid == 123 | nodeid == 145 | nodeid == 3 | nodeid == 141) %>%
  mutate(nodeid = as.character(nodeid)) %>%
  ggplot(aes(x = result_time, y = humid_temp)) +
  geom_line(aes(colour = nodeid)) +
  labs(x = "", y = "Temperature") +
  theme_bw()

plot2 <- data_all %>%
  filter(nodeid == 78 | nodeid == 123 | nodeid == 145 | nodeid == 3 | nodeid == 141) %>%
  mutate(nodeid = as.character(nodeid)) %>%
  ggplot(aes(x = result_time, y = humidity)) +
  geom_line(aes(colour = nodeid)) +
  labs(x = "", y = "Humidity") +
  theme_bw()

plot3 <- data_all %>%
  filter(nodeid == 78 | nodeid == 123 | nodeid == 145 | nodeid == 3 | nodeid == 141) %>%
  mutate(nodeid = as.character(nodeid)) %>%
  ggplot(aes(x = result_time, y = voltage)) +
  labs(x = "Date", y = "Voltage") +
  geom_line(aes(colour = nodeid)) +
  theme_bw()

grid.arrange(plot1, plot2, plot3, nrow = 3)
```

After removing observations with voltage lower than 2.4 and larger than 3, we manually identified some easy outliers, such as 2 temperature outliers from node 123, 3 humidity outliers from node 118 and incident PAR outliers from node 40. After checking all 98 readings from node 40, we decided to remove node 40 entirely as node 40 fails to operate almost at the beginning of the experiment.

```{r}
# outlier removal, fast version
data <- data_all %>%
  filter(voltage > 2.4, voltage < 3, humid_temp < 100, humidity < 110, nodeid != 40)
```

There are obviously no more outliers for voltage, temperature and humidity from histogram. For rest of the two variables, even if we removed observations with reading 0s to make the plot look better, the histograms are still not convincing enough. To check the behavior of the long-tailed incident and reflected PAR, we plot the overall trend of PAR against time for some of the nodes with extremely high readings. All nodes are perfectly aligned with almost the same absolute value, which indicates that the readings are valid.

```{r, fig.cap="Histogram after outlier objection", fig.width=8, fig.height=5}
plot1 <- data %>%
           ggplot(aes(x = voltage)) +
           geom_histogram(na.rm = T, bins = 50) +
           labs(x = "Voltage", y = "Count") +
           theme_bw()

plot2 <- data %>%
           ggplot(aes(x = humid_temp)) +
           geom_histogram(na.rm = T, bins = 50) +
           labs(x = "Temperature", y = "Count") +
           theme_bw()

plot3 <- data %>%
           ggplot(aes(x = humidity)) +
           geom_histogram(na.rm = T, bins = 50) +
           labs(x = "Humidity", y = "Count") +
           theme_bw()

plot4 <- data %>%
           filter(hamatop > 0) %>%
           ggplot(aes(x = hamatop)) +
           geom_histogram(na.rm = T, bins = 50) +
           labs(x = "Incident PAR", y = "Count") +
           theme_bw()

plot5 <- data %>%
           filter(hamabot > 0) %>%
           ggplot(aes(x = hamabot)) +
           geom_histogram(na.rm = T, bins = 50) +
           labs(x = "Reflected PAR", y = "Count") +
           theme_bw()

grid.arrange(plot1, plot2, plot3, plot4, plot5, nrow = 5)
```

```{r, fig.cap="Large-reading nodes' pattern against time", fig.width=8, fig.height=5}
nodeid_top <- data %>%
                    mutate(abnormal = case_when(hamatop >= 100000 ~ 1,
                                                TRUE ~ 0)) %>%
                    dplyr::count(nodeid, abnormal) %>%
                    filter(abnormal == 1, n >= 900) %>%
                    select(nodeid) %>%
                    distinct()

plot1 <- merge(data, nodeid_top, by = "nodeid") %>%
  mutate(nodeid = as.character(nodeid)) %>%
  ggplot(aes(x = result_time, y = hamatop)) +
  geom_line(aes(colour = nodeid)) +
  labs(x = "", y = "Incident PAR")

nodeid_bottom <- data %>%
                    mutate(abnormal = case_when(hamabot >= 5000 ~ 1,
                                                TRUE ~ 0)) %>%
                    dplyr::count(nodeid, abnormal) %>%
                    filter(abnormal == 1, n >= 100) %>%
                    select(nodeid) %>%
                    distinct()

plot2 <- merge(data, nodeid_bottom, by = "nodeid") %>%
  mutate(nodeid = as.character(nodeid)) %>%
  ggplot(aes(x = result_time, y = hamabot)) +
  geom_line(aes(colour = nodeid)) +
  labs(x = "Date", y = "Reflected PAR")


grid.arrange(plot1, plot2, nrow = 2)
```

(e) Besides the outliers removed above, there are other outliers as well. From the analysis above we see that nodes tend to generate abnormal readings when their voltage runs low right before they are dead. When the reading is not extremely absurd, they cannot be detected by histograms/summary statistics but they are indeed problematic. We identify and remove some of this type of outliers by comparing the deviation of each node from the average reading of each day. We only consider the case that large deviation is at the last day certain node generates readings.

```{r}
data <- data %>%
  mutate(date = date(result_time)) %>%
  filter(nodeid != 3 | date != "2004-05-10", 
         nodeid != 59 | date != "2004-05-19", 
         nodeid != 27 | date != "2004-04-28",
         nodeid != 78 | date != "2004-05-08", 
         nodeid != 140 | date != "2004-05-08", 
         nodeid != 68 | date != "2004-05-06",
         nodeid != 198 | date != "2004-05-10", 
         nodeid != 16 | date != "2004-05-05",
         nodeid != 136 | date != "2004-05-06", 
         nodeid != 65 | date != "2004-05-06")

data <- data %>%
  mutate(date = date(result_time)) %>%
  filter(nodeid != 122 | date != "2004-05-07", 
         nodeid != 15 | date != "2004-04-30")
```

# 3. Data Exploration

```{r fig.cap="Period Selection" ,fig.width=5, fig.height=3}
data %>%
  mutate(day = as.POSIXct(round(result_time, "days"))) %>%
  dplyr::count(day) %>%
  arrange(day) %>%
  ggplot(aes(x = day, y = n)) +
  geom_point() +
  geom_vline(xintercept = as.numeric(as.POSIXct(c("2004-05-26")))) +
  labs(x = "Day", y = "Count of data points per day") +
  annotate("text", x = as.POSIXct(c("2004-05-31")), y = 10000,
           label = "May 26", size = 4) +
  theme_bw()
```

```{r}
data <- data %>%
  filter(result_time < as.POSIXct("2004-05-27"))
```


(a) We decide to present two scatter plots that show significant linear relationships: \texttt{Reflected PAR} versus \texttt{Incident PAR}, \texttt{Humidity} versus \texttt{Temperature}. The time period chosen is from beginning to 2004-05-26. The reason for this choice of time period is that significant number of nodes become inactive after 2004-05-26 (elbow point) and that the relationship remains similar for future time periods. The plot shows a positive relationship between reflected PAR and incident PAR. This follows our belief, since both variables are measuring the amount of sunlight. However, as the scatter points indicate, the true relationship between these two variables may not be linear. The plot shows a strong negative relationship between relative humidity and temperature. This is consistent with the observation mentioned in the paper: warm days are dryer and cold days are more humid in the experiment site.

```{r fig.cap="Scatter plots: Inflected vs Reflected PAR, Temperature vs Humidity", fig.width=5, fig.height=3}
fig1 <- data %>%
  head(10) %>%
  ggplot(aes(x = hamatop, y = hamabot)) +
  geom_point(alpha = 0.3) +
  geom_smooth(formula = y ~ x, method = "lm", se = FALSE) +
  labs(title = "", x = "Incident PAR", y = "Reflected PAR") +
  theme_bw()

fig2 <- data %>%
  head(10) %>%
  ggplot(aes(x = humid_temp, y = humidity)) +
  geom_point(alpha = 0.3) +
  geom_smooth(formula = y ~ x, method = "lm", se = FALSE) +
  labs(title = "", x = "Temperature", y = "Relative Humidity") +
  theme_bw()

grid.arrange(fig1, fig2, ncol = 2)
```

(b) There seems to be a positive linear relationship between Incident PAR and height. This is consistent with our common sense that higher nodes receive more sunlight. Lower height nodes have significantly fewer high values for incident PAR. Moreover, reflected PAR and incident PAR are positively correlated from the analysis in last part.

```{r fig.cap="Other scatter plots", fig.width=5, fig.height=5}
fig3 <- data %>%
  head(10) %>%
  ggplot(aes(x = hamatop, y = height)) +
  geom_point(na.rm = T, alpha = 0.3) +
  geom_smooth(formula = y ~ x, method = "lm", se = FALSE) +
  labs(title = "", x = "Incident PAR", y = "Node Height") +
  theme_bw()

fig4 <- data %>%
  head(10) %>%
  ggplot(aes(x = hamatop, y = humid_temp)) +
  geom_point(na.rm = T, alpha = 0.3) +
  geom_smooth(formula = y ~ x, method = "lm", se = FALSE) +
  labs(title = "", x = "Incident PAR", y = "Temperature") +
  theme_bw()

fig5 <- data %>%
  head(10) %>%
  ggplot(aes(x = hamatop, y = hamabot)) +
  geom_point(na.rm = T, alpha = 0.3) +
  geom_smooth(formula = y ~ x, method = "lm", se = FALSE) +
  labs(title = "", x = "Incident PAR", y = "Reflected PAR") +
  theme_bw()

fig6 <- data %>%
  head(10) %>%
  ggplot(aes(x = hamatop, y = humidity)) +
  geom_point(na.rm = T, alpha = 0.3) +
  geom_smooth(formula = y ~ x, method = "lm", se = FALSE) +
  labs(title = "", x = "Incident PAR", y = "Humidity") +
  theme_bw()

grid.arrange(fig3, fig4, fig5, fig6, nrow = 2, ncol = 2)
```

(c) We use time series analysis with different height levels to reflect the general trend for temperature, humidity, reflected PAR and incident PAR. First, we use daily mean to summarize the data. From the figure, we see that the higher the nodes, the more they are related to higher temperatures, incident and reflected PARs. Lower nodes tend to have slightly higher relative humidity. Second, we use hourly mean to summarize the data. Conclusions are similar regarding height. Temperature reaches peak around noon and the peak of PARs turn out to be around 3pm in the afternoon. Plots for hourly trend are omitted to save space.

```{r fig.cap="Time series plots for the four environmental variables", fig.width=10, fig.height=5}
temp_plot <- data %>%
  group_by(date = date(result_time), height) %>%
  dplyr::summarise(across(humid_temp, mean), .groups = "drop") %>%
  ggplot(aes(x = date, y = humid_temp, color = height, group = height)) +
  geom_line() +
  scale_x_date(date_breaks = "3 days", limits = c(as_date("2004-04-28"), as_date("2004-05-27")), expand = c(0,0), date_labels = "%B %d") +
  scale_color_gradient(low = "orange", high = "blue") +
  labs(title = "Temperature", x = "", y = "", color = "Node Height") +
  theme_bw()

humidity_plot <- data %>%
  group_by(date = date(result_time), height) %>%
  dplyr::summarise(across(humidity, mean), .groups = "drop") %>%
  ggplot(aes(x = date, y = humidity, color = height, group = height)) +
  geom_line() +
  scale_x_date(date_breaks = "3 days", limits = c(as_date("2004-04-28"), as_date("2004-05-27")), expand = c(0,0), date_labels = "%B %d") +
  scale_color_gradient(low = "orange", high = "blue") +
  labs(title = "Relative Humidity", x = "", y = "", color = "Node Height") +
  theme_bw()

incident_plot <- data %>%
  group_by(date = date(result_time), height) %>%
  dplyr::summarise(across(hamatop, mean), .groups = "drop") %>%
  ggplot(aes(x = date, y = hamatop, color = height, group = height)) +
  geom_line() +
  scale_x_date(date_breaks = "3 days", limits = c(as_date("2004-04-28"), as_date("2004-05-27")), expand = c(0,0), date_labels = "%B %d") +
  scale_color_gradient(low = "orange", high = "blue") +
  labs(title = "Incident PAR", x = "", y = "", color = "Node Height") +
  theme_bw()

reflected_plot <- data %>%
  group_by(date = date(result_time), height) %>%
  dplyr::summarise(across(hamabot, mean), .groups = "drop") %>%
  ggplot(aes(x = date, y = hamabot, color = height, group = height)) +
  geom_line() +
  scale_x_date(date_breaks = "3 days", limits = c(as_date("2004-04-28"), as_date("2004-05-27")), expand = c(0,0), date_labels = "%B %d") +
  scale_color_gradient(low = "orange", high = "blue") +
  labs(title = "Reflected PAR", x = "", y = "", color = "Node Height") +
  theme_bw()

grid.arrange(temp_plot, humidity_plot, incident_plot, reflected_plot, ncol = 2, nrow = 2)
```

```{r fig.cap="Trend of the four environmental variables against height", fig.width=10, fig.height=5}
# temp_plot <- data %>%
#   group_by(date = hour(result_time), height) %>%
#   dplyr::summarise(across(humid_temp, mean), .groups = "drop") %>%
#   ggplot(aes(x = date, y = humid_temp, color = height, group = height)) +
#   geom_line() +
#   scale_color_gradient(low = "orange", high = "blue") +
#   labs(title = "Temperature", x = "", y = "", color = "Node Height") +
#   theme_bw()
# 
# humidity_plot <- data %>%
#   group_by(date = hour(result_time), height) %>%
#   dplyr::summarise(across(humidity, mean), .groups = "drop") %>%
#   ggplot(aes(x = date, y = humidity, color = height, group = height)) +
#   geom_line() +
#   scale_color_gradient(low = "orange", high = "blue") +
#   labs(title = "Relative Humidity", x = "", y = "", color = "Node Height") +
#   theme_bw()
# 
# incident_plot <- data %>%
#   group_by(date = hour(result_time), height) %>%
#   dplyr::summarise(across(hamatop, mean), .groups = "drop") %>%
#   ggplot(aes(x = date, y = hamatop, color = height, group = height)) +
#   geom_line() +
#   scale_color_gradient(low = "orange", high = "blue") +
#   labs(title = "Incident PAR", x = "Hours", y = "", color = "Node Height") +
#   theme_bw()
# 
# reflected_plot <- data %>%
#   group_by(date = hour(result_time), height) %>%
#   dplyr::summarise(across(hamabot, mean), .groups = "drop") %>%
#   ggplot(aes(x = date, y = hamabot, color = height, group = height)) +
#   geom_line() +
#   scale_color_gradient(low = "orange", high = "blue") +
#   labs(title = "Reflected PAR", x = "Hours", y = "", color = "Node Height") +
#   theme_bw()
# 
# grid.arrange(temp_plot, humidity_plot, incident_plot, reflected_plot, ncol = 2, nrow = 2)
```

(d) Four variables are selected for PCA: \texttt{humidity}, \texttt{temperature}, \texttt{reflected PAR}, \texttt{incident PAR}. From the screeplot, this data can be approximated by low-dimensional representation. According to the rule of elbow and Kaiser's rule, we see that the first two PCs explain 84.6\% of the total variance, so they serve as a good low-dimensional representation.

```{r fig.cap="Screeplot", fig.width=5, fig.height=3}
pca <- data %>%
  select(humidity, humid_temp, hamatop, hamabot) %>% 
  prcomp(center = TRUE, scale = TRUE)
# screeplot
eigenvalues <- pca$sdev^2
eigs_cum <- cumsum(eigenvalues) /sum(eigenvalues)
ggplot() + 
  geom_point(aes(x = 1:length(eigenvalues), y = eigs_cum)) + 
  geom_line(aes(x = 1:length(eigenvalues), y = eigs_cum)) +
  labs(x = "first PCs", y = "Variance explained") +
  theme_bw()
```

# 4. Interesting findings

```{r fig.cap="There is similar relations for temperature versus humidity", fig.height=3, fig.width=5}
# Show that the trend for temperature versus humidity is similar across choices we made
data %>%
  mutate(hour = hour(result_time),
         date = date(result_time)) %>%
  filter(date == "2004-05-06" | date == "2004-05-07" | date == "2004-05-08") %>%
  mutate(date = as.factor(date)) %>%
  ggplot(aes(x = humid_temp, y = humidity, color = date)) +
  geom_point(na.rm = T) +
  labs(title = "", x = "Temperature", y = "Humidity") +
  theme_bw()
```

(a) We apply Gaussian mixture model to environmental variables: \texttt{humidity} and \texttt{temperature}. We see that humidity and temperature trends are very similar within one day in May. For the sake of convenience, we choose a day in May (May 7th) for observation. The reason for picking this date is we have shown that the trends for temperature versus humidity are similar across different days (May 6th-8th). From the density curve plot, Gaussian mixture model divides the observations into two groups: one with high temperature and low humidity, the other with low temperature and high humidity. To figure out the reason for such division, we create a scatter plot on height versus time. There is no evident height difference between these two groups, but there is an obvious cutoff at 8am and 9pm, which correspond to the boundary between daytime and nightime. This shows a logical but indeed interesting finding: high temperature and low humidity before sunset, and low temperature and high humidity after sunset.

```{r messages=FALSE, warnings=FALSE, results = 'hide', fig.cap="Gaussian Mixture Model", fig.width=5, fig.height=3}
# GMM
library(mixtools)
df <- data[as_date(data$result_time) == "2004-05-07",]
em <- mvnormalmixEM(df[, c("humidity", "humid_temp")])
# plot(em, whichplots = 2)
```

```{r fig.cap="GMM grouping result", fig.width=8, fig.height=3}
df$cluster <- as.factor(apply(em$posterior, 1, which.max))
plot1 <- df %>%
  ggplot() +
  geom_point(aes(x = humidity, y = humid_temp, group = cluster, color = cluster))
plot2 <- df %>%
  ggplot() +
  geom_point(aes(x = height, y = result_time, group = cluster, color = cluster))
grid.arrange(plot1, plot2, ncol = 2)
```

(b) We apply PCA to the four variables with all the observations after scaling. From 3(d), the first two PCs explain the majority of the information. From the PC scores, \texttt{humidity} and \texttt{temperature} are more important for PC1. \texttt{Incident PAR} and \texttt{reflected PAR} are more important for PC2. From Figure, we see \texttt{humidity} and \texttt{temperature} almost have the opposite effect on PC1 and PC2. This is consistent with the fact that \texttt{humidity} and \texttt{temperature} have a negative linear relation, as shown in Part 3.

```{r fig.cap="PCA", fig.width=5, fig.height=3}
# PCA
library(ggfortify)
autoplot(pca, col = "hamabot", label = FALSE, loadings.label = TRUE) +
  theme_bw()
```

(c) By K-Means clustering, \texttt{humidity} and \texttt{temperature} have inherent relations to the height of nodes. We compute the averages of \texttt{temperature} and \texttt{humidity} by height. Then we start clustering with two centroids and then look at the distribution of height by cluster. The distributions show differences in height, so there are inherent relations in between. The same reasoning applies for \texttt{reflected PAR} and \texttt{incident PAR}, as well as these pairs against the time of recording.

```{r fig.cap="K-Means against height", fig.width=8, fig.height=3}
# KMeans for humidity annd temp against height
height <- data %>%
  group_by(height) %>%
  summarise(across(c(humidity, humid_temp), mean))

set.seed(2022)
cluster <- height %>%
  select(-height) %>%
  kmeans(centers = 2, nstart = 10)

height1 <-height %>%
  mutate(cluster = factor(cluster$cluster)) %>%
  ggplot(aes(x = height, fill = cluster, group = cluster)) +
  geom_density(alpha = 0.7, color = FALSE) +
  labs(title = "KMeans for Humidity versus Temperature", x = "Height (m)", y = "", fill = "Cluster") +
  scale_fill_viridis_d() +
  theme_bw()

# KMeans for hamatop and hamabot against height
height <- data %>%
  group_by(height) %>%
  summarise(across(c(hamatop, hamabot), mean))

set.seed(2022)
cluster <- height %>%
  select(-height) %>%
  kmeans(centers = 2, nstart = 10)

height2 <- height %>%
  mutate(cluster = factor(cluster$cluster)) %>%
  ggplot(aes(x = height, fill = cluster, group = cluster)) +
  geom_density(alpha = 0.7, color = FALSE) +
  labs(title = "KMeans for Incident versus Reflected PAR", x = "Height (m)", y = "", fill = "Cluster") +
  scale_fill_viridis_d() +
  theme_bw()

grid.arrange(height1, height2, nrow = 1, ncol = 2)
```

```{r fig.cap="K-Means against time", fig.width=8, fig.height=3}
hour <- data %>%
  mutate(hour = hour(result_time)) %>%
  group_by(hour) %>%
  summarise(across(c(humidity, humid_temp), mean))

set.seed(2022)
cluster <- hour %>%
  select(-hour) %>%
  kmeans(centers = 2, nstart = 10)

hour1 <- hour %>%
  mutate(cluster = factor(cluster$cluster)) %>%
  ggplot(aes(x = hour, fill = cluster, group = cluster)) +
  geom_density(alpha = 0.7, color = FALSE) +
  labs(title = "KMeans for Humidity versus Temperature", x = "Hour", y = "", fill = "Cluster") +
  scale_fill_viridis_d() +
  theme_bw()

# KMeans for hamatop and hamabot against hour
hour <- data %>%
  mutate(hour = hour(result_time)) %>%
  group_by(hour) %>%
  summarise(across(c(hamatop, hamabot), mean))

set.seed(2022)
cluster <- hour %>%
  select(-hour) %>%
  kmeans(centers = 2, nstart = 10)

hour2 <- hour %>%
  mutate(cluster = factor(cluster$cluster)) %>%
  ggplot(aes(x = hour, fill = cluster, group = cluster)) +
  geom_density(alpha = 0.7, color = FALSE) +
  labs(title = "KMeans for Incident versus Reflected PAR", x = "Hour", y = "", fill = "Cluster") +
  scale_fill_viridis_d() +
  theme_bw()

grid.arrange(hour1, hour2, nrow = 1, ncol = 2)
```

```{r fig.cap="Hierarchical clustering; Gap statistics plot", fig.height=8, fig.width=15}
# library(cluster)
# data = cbind(data, data.matrix(pca$x)[, c(1, 2)])
# df1 <- data[as_date(data$result_time) == "2004-05-07", c("PC1", "PC2")]
# m <- c("average", "single", "complete", "ward")
# names(m) <- c("average", "single", "complete", "ward")
# agg_coeff <- function(x){
#   agnes(df1, method = x)$ac
# }
# cluster <- df1 %>%
#   agnes(method = "ward")
# pltree(cluster, cex = 0.6, hang = -1, main = "Dendogram") # plot the tree
# # apply gap statistic to compare total intra-cluster variation
# library(factoextra)
# gap_stat <- clusGap(df1, FUN = hcut, nstart = 25, K.max = 10, B = 50)
# # choose k with the highest gap statistic
# fviz_gap_stat(gap_stat)
# final_clust <- hclust(dist(df1, method = "euclidean"), method = "ward.D2")
# agnes_group <- cutree(final_clust, k = 5)
# df1 <- data.frame(cbind(net_data_loc[as_date(net_data_loc$result_time) == "2004-05-07", ], agnes_group = as.factor(agnes_group)))
# df1 %>% 
#   ggplot() +
#   geom_point(aes(result_time, Height, group = agnes_group, color = agnes_group), alpha = 0.5)
# df1[df1$agnes_group == 4|df1$agnes_group == 5, ] %>%
#   ggplot() +
#   geom_point(aes(humid_temp, humidity, group = agnes_group, color = agnes_group), alpha = 0.5)
```

# 5. Graph Critique

(a) Since there are too many zeros in \texttt{incident PAR} and \texttt{reflected PAR} that are not going to help with tail analysis, we filter all the zeros in the data and take log for transformation.

```{r fig.cap="log transform of data", fig.width=8, fig.height=3}
plot1 <- data %>% 
  filter(hamatop > 0) %>%
  mutate(hamatop = log(hamatop)) %>%
  ggplot() +
  geom_histogram(aes(x = hamatop), bins = 40) +
  labs(x = "μmol/m2/s", y = "counts", title = "Incident PAR")

plot2 <- data %>% 
  filter(hamabot > 0) %>%
  mutate(hamabot = log(hamabot)) %>%
  ggplot() +
  geom_histogram(aes(x = hamabot), bins = 40) +
  labs(x = "μmol/m2/s", y = "counts", title = "Reflected PAR")

grid.arrange(plot1, plot2, ncol = 2)
```

(b) From our understanding, the box plots in figure 3(c) and 3(d) in the paper show the distributions of different variables over height. The paper suggests that spatial gradients might exist over the height of the tree. However, we don't think the box plots convey a complete message without observing the temporal readings. Moreover, the difference brought in by temporal factors may cover the difference brought in by spatial gradients. Thus, we might as well simulate figure 4 presented in the paper to plot trends of the mean values of four environmental variables against height over different time periods during a day, and create several trend plots over different days. Each of color in the plots on the right represents different dates. Line plot turns out to be a better option to convey trends than box plot. We can see the spatial gradients clearly over time: \texttt{humidity} and \texttt{temperature} change across time periods within a day as well as the time periods across several days, but the trend over height is not obvious; \texttt{Incident PAR} and \texttt{reflected PAR} change across time periods within a day as well as the time periods across several days, and the trend over height is obvious.

```{r}
hour <- as.integer(format(data$result_time, "%H"))
data$Period <- ifelse(hour < 6, "0-6",
                      ifelse(hour < 13, "6-13", ifelse(hour < 20, "13-20", "20-24")))
data$Day <- format(data$result_time, "%b %d")
```

```{r fig.cap="mean of humidity and temperature during a day and during days", fig.width=8, fig.height=5}
# humidity
humidity.period.mean <- data %>%
  select(Period, humidity, height) %>%
  group_by(Period, height) %>%
  mutate(mean = mean(humidity)) %>%
  select(Period, height, mean) %>%
  unique()
# mean by period
fig1 <- humidity.period.mean %>%
  ggplot() +
  geom_line(mapping = aes(x = height, y = mean, group = Period, color = Period), size = 0.3) +
  labs(y = "humidity")
# mean by days
humidity.day.mean <- data %>%
  select(Day, humidity, height) %>%
  group_by(Day, height) %>%
  mutate(mean = mean(humidity)) %>%
  select(Day, height, mean) %>%
  unique() %>%
  arrange(Day)
fig2 <- humidity.day.mean %>%
  ggplot() +
  geom_line(mapping = aes(x = height, y = mean, group = Day, color= Day), size = 0.3,
            show.legend = F) +
  labs(y = "humidity")

# temperature
temp.period.mean <- data %>%
  select(Period, humid_temp, height) %>%
  group_by(Period, height) %>%
  mutate(mean = mean(humid_temp)) %>%
  select(Period, height, mean) %>%
  unique()
# mean by period
fig3 <- temp.period.mean %>%
  ggplot() +
  geom_line(mapping = aes(x = height, y = mean, group = Period, color = Period), size = 0.3) +
  labs(y = "temperature")
# mean by days
temp.day.mean <- data %>%
  select(Day, humid_temp, height) %>%
  group_by(Day, height) %>%
  mutate(mean = mean(humid_temp)) %>%
  select(Day, height, mean) %>%
  unique() %>%
  arrange(Day)
fig4 <- temp.day.mean %>%
  ggplot() +
  geom_line(mapping = aes(x = height, y = mean, group = Day, color= Day), size = 0.3,
            show.legend = F) +
  labs(y = "temperature")

grid.arrange(fig1, fig2, fig3, fig4, nrow = 2, ncol = 2)
```

```{r fig.cap="mean of Incident and Reflected PAR during a day and during days", fig.width=8, fig.height=5}
# hamatop
hamatop.period.mean <- data %>%
  select(Period, hamatop, height) %>%
  group_by(Period, height) %>%
  mutate(mean = mean(hamatop)) %>%
  select(Period, height, mean) %>%
  unique()
# mean by period
fig5 <- hamatop.period.mean %>%
  ggplot() +
  geom_line(mapping = aes(x = height, y = mean, group = Period, color = Period), size = 0.3) +
  labs(y = "Incident PAR")
# mean by days
hamatop.day.mean <- data %>%
  select(Day, hamatop, height) %>%
  group_by(Day, height) %>%
  mutate(mean = mean(hamatop)) %>%
  select(Day, height, mean) %>%
  unique() %>%
  arrange(Day)
fig6 <- hamatop.day.mean %>%
  ggplot() +
  geom_line(mapping = aes(x = height, y = mean, group = Day, color= Day), size = 0.3,
            show.legend = F) +
  labs(y = "Incident PAR")

# hamabot
hamabot.period.mean <- data %>%
  select(Period, hamabot, height) %>%
  group_by(Period, height) %>%
  mutate(mean = mean(hamabot)) %>%
  select(Period, height, mean) %>%
  unique()
# mean by period
fig7 <- hamabot.period.mean %>%
  ggplot() +
  geom_line(mapping = aes(x = height, y = mean, group = Period, color = Period), size = 0.3) +
  labs(y = "Reflected PAR")
# mean by days
hamabot.day.mean <- data %>%
  select(Day, hamabot, height) %>%
  group_by(Day, height) %>%
  mutate(mean = mean(hamabot)) %>%
  select(Day, height, mean) %>%
  unique() %>%
  arrange(Day)
fig8 <- hamabot.day.mean %>%
  ggplot() +
  geom_line(mapping = aes(x = height, y = mean, group = Day, color= Day), size = 0.3,
            show.legend = F) +
  labs(y = "Reflected PAR")
grid.arrange(fig5, fig6, fig7, fig8, nrow = 2, ncol = 2)
```

(c) The disadvantages of the first two plots are that there are too many lines in the plot. A way to simplify the plot is to divide the nodes grouped by different height levels and plot the change of \texttt{humidity} over time. We can also simplify the plots for \texttt{temperature}, \texttt{incident PAR} and \texttt{reflected PAR}.

```{r fig.cap="plot simplification", fig.width=8, fig.height=5}
# humid
humid.height.mean <- data[data$Day == "May 01", ] %>%
  select(result_time, humidity, height) %>%
  mutate(height_group = cut(height, 5)) %>%
  group_by(result_time, height_group) %>%
  mutate(mean = mean(humidity)) %>%
  select(result_time, height_group, mean) %>%
  unique()

fig1 <- humid.height.mean %>%
  melt(id.vars = c("result_time", "height_group")) %>%
  ggplot() +
  geom_line(mapping = aes(x = result_time, y = value, group = height_group, color = height_group), size = 0.3) +
  scale_color_brewer(type = "equal", palette = "Set2") +
  labs(x = "Time", y = "Humidity", color = "height")
# temperature
temp.height.mean <- data[data$Day == "May 01", ] %>%
  select(result_time, humid_temp, height) %>%
  mutate(height_group = cut(height, 5)) %>%
  group_by(result_time, height_group) %>%
  mutate(mean = mean(humid_temp)) %>%
  select(result_time, height_group, mean) %>%
  unique()

fig2 <- temp.height.mean %>%
  melt(id.vars = c("result_time", "height_group")) %>%
  ggplot() +
  geom_line(mapping = aes(x = result_time, y = value, group = height_group, color = height_group), size = 0.3) +
  scale_color_brewer(type = "equal", palette = "Set2") +
  labs(x = "Time", y = "Temperature", color = "height")
# hamatop
hamatop.height.mean <- data[data$Day == "May 01", ] %>%
  select(result_time, hamatop, height) %>%
  mutate(height_group = cut(height, 5)) %>%
  group_by(result_time, height_group) %>%
  mutate(mean = mean(hamatop)) %>%
  select(result_time, height_group, mean) %>%
  unique()

fig3 <- hamatop.height.mean %>%
  melt(id.vars = c("result_time", "height_group")) %>%
  ggplot() +
  geom_line(mapping = aes(x = result_time, y = value, group = height_group, color = height_group), size = 0.3) +
  scale_color_brewer(type = "equal", palette = "Set2") +
  labs(x = "Time", y = "Incident PAR", color = "height")
# hamabot
hamabot.height.mean <- data[data$Day == "May 01", ] %>%
  select(result_time, hamabot, height) %>%
  mutate(height_group = cut(height, 5)) %>%
  group_by(result_time, height_group) %>%
  mutate(mean = mean(hamabot)) %>%
  select(result_time, height_group, mean) %>%
  unique()

fig4 <- hamabot.height.mean %>%
  melt(id.vars = c("result_time", "height_group")) %>%
  ggplot() +
  geom_line(mapping = aes(x = result_time, y = value, group = height_group, color = height_group), size = 0.3) +
  scale_color_brewer(type = "equal", palette = "Set2") +
  labs(x = "Time", y = "Reflected PAR", color = "height")
grid.arrange(fig1, fig2, fig3, fig4, ncol = 2, nrow = 2)
```

(d) We can concatenate the fourth plots of (a) and (b) respectively and combine the bars with the same height value. This will allow us to see the overlap between \texttt{net-data} and \texttt{log-data}. We can improve the third plots of (a) and (b) respectively by using bar plots instead of scatter plots. The second plots of (a) and (b) feature too many box plots which lack interpretability. A way to enhance interpretability is to partition the days into several groups and create boxplots based on the grouped result. The first plots of (a) and (b) respectively have the worst interpretation: the meaning of the x-axis is very vague to readers.

```{r}
log_data <- merge(log_data, loc_data, by.x = "nodeid", by.y = "ID")
net_data <- merge(net_data, loc_data, by.x = "nodeid", by.y = "ID")
log_data$category = "log"
net_data$category = "net"
all <- rbind(log_data, net_data)
```

```{r, fig.cap="A better visualization for net and log data", fig.height=5, fig.width=8}
all %>%
  head(10) %>%
  select(Height, result_time, category) %>%
  unique() %>%
  ggplot() +
  geom_point(aes(x = as.POSIXct(result_time), y = as.factor(Height), color = category, group = category), size = 0.01, position = position_dodge(width = 0.6)) +
  labs(x = "Days", y = "Height") +
  scale_x_datetime(breaks = date_breaks("5 day"))
```