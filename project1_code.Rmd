---
title: "project1_code"
author: "Tianyu"
date: "2022-09-18"
output: html_document
---

### This is the R code demo for project 1 of STA 521, Fall 2022 ###


```{r setup, include=FALSE}
library(tidyverse)
library(gridExtra)
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
### 2(a) Check histogram of each variable. 
log_data <- read_csv("~/sta 521 proj1/sonoma-data-log.csv")
net_data <- read_csv("~/sta 521 proj1/sonoma-data-net.csv")
```

```{r}
loc_data <- read.table("~/sta 521 proj1/mote-location-data.txt", header = T, sep = "")
```

# Part 2 Data Cleaning

## (a)

First use summary to extract useful insights from summary statistics.

```{r}
variables = c("humidity", "humid_temp", "hamatop", "hamabot", "voltage")
log_data |>
  select(all_of(variables)) |>
  summary()
```

```{r}
net_data |>
  select(all_of(variables)) |>
  summary()
```

From the summary statistics we know that 
1. Variable voltage for two datasets are not in the same domain.
2. There are NAs for all of the datasets.

We know from the paper that the incident and reflected PAR measurements were collected by two Hamamatsu S1087 photodiodes interfaced to the 10-bit
ADC on Mica2Dot. From user manual (http://www-db.ics.uci.edu/pages/research/quasar/MPR-MIB%20Series%20User%20Manual%207430-0021-06_A.pdf Page 25) we found the formula of conversion to be $V_{batt} = V_{ref} \times ADC\_FS / ADC\_Count$. The voltage data from net dataset is converted to the right range after the conversion: 

```{r}
# 
ADC_FS = 1024
V_ref = 0.6 

net_data |>
  select(voltage) |>
  mutate(voltage_battery = V_ref * ADC_FS / voltage) |>
  summary()
```

To make sure the conversion is reasonable, plot the histogram of both voltage columns after removing NAs and outliers from eye-ball checking (Outlier detection and removal is covered in detail in part 2(d)).

```{r}
# Variable voltage
plot1 <- log_data |>
           ggplot(aes(x = voltage)) +
           geom_histogram(na.rm = T, bins = 50)

plot2 <- net_data |>
           ggplot(aes(x = voltage)) +
           geom_histogram(na.rm = T, bins = 50)

grid.arrange(plot1, plot2, ncol = 2)
```

```{r}
# Variable voltage
plot1 <- log_data |>
           filter(voltage >= 2) |>
           ggplot(aes(x = voltage)) +
           geom_histogram(na.rm = T, bins = 50)

plot2 <- net_data |>
           filter(voltage <= 400) |>
           mutate(voltage_battery = V_ref * ADC_FS / voltage) |>
           ggplot(aes(x = voltage_battery)) +
           geom_histogram(na.rm = T, bins = 50)

grid.arrange(plot1, plot2, ncol = 2)
```

We can safely replace original voltage with the transformed values.

```{r}
net_data <- net_data |>
              mutate(voltage = V_ref * ADC_FS / voltage)
```

## (b)

It turns out that when a rows contains any NA, all four variables of interests are NA:

```{r}
colSums(is.na(log_data))
sum(apply(log_data, 1, anyNA))
colSums(is.na(net_data))
sum(apply(net_data, 1, anyNA))
```

Identify corresponding date and time period:

```{r}
log_data_na <- log_data[rowSums(is.na(log_data)) > 0,]
log_data_na |> 
  select(result_time) |>
  distinct()
```

However, note that the log data has the same result_time. Therefore, we should consider using epoch.

```{r}
log_data_loc |>
  select(result_time) |>
  distinct()
```

```{r}
log_data_na |> 
  select(epoch) |>
  distinct()
```


Number of rows after distinct() is the same as number of NA. In other words, all result_time are different.

```{r}
net_data_na <- net_data[rowSums(is.na(net_data)) > 0,]
net_data_na |> 
  select(result_time) |>
  distinct()
```

Examine more on row 9 and row 10 as they are the same when displayed above.

```{r}
net_data_na_time <- net_data_na |> 
                      select(result_time) |>
                      distinct()
na_result_time <- net_data_na_time$result_time
na_result_time[9] - na_result_time[10]
```

It turns out that the difference is in seconds. Therefore, we can round the date time to minutes level. As can be seen below, 3756/4262 rows remain. All of them indeed have different date and time.

```{r}
net_data_na |> 
  select(result_time) |>
  mutate(result_time = as.POSIXct(round(result_time, "mins"))) |>
  distinct()
```

514/4262 rows remain if round to hours

```{r}
net_data_na |> 
  select(result_time) |>
  mutate(result_time = as.POSIXct(round(result_time, "hours"))) |>
  group_by(result_time) |>
  dplyr::summarise(count = n())
  # dplyr::count(result_time) equivalent
```

```{r}
net_data_na |> 
  select(result_time) |>
  mutate(result_time = as.POSIXct(round(result_time, "hours"))) |>
  ggplot(aes(x = result_time)) +
  geom_bar()
```

The time spans 22 days from May 08 to May 29 (everyday in this span).

```{r}
net_data_na |> 
  select(result_time) |>
  mutate(result_time = as.POSIXct(round(result_time, "days"))) |>
  dplyr::count(result_time)
```

```{r}
net_data_na |> 
  select(result_time) |>
  mutate(result_time = as.POSIXct(round(result_time, "days"))) |>
  ggplot(aes(x = result_time)) +
  geom_bar()
```

Remove missing values and do sanity check.

```{r}
nrow_log_data <- nrow(log_data)
nrow_net_data <- nrow(net_data)
log_data <- log_data |> drop_na()
net_data <- net_data |> drop_na()
nrow_log_data - nrow(log_data)
nrow_net_data - nrow(net_data)
```

```{r}
nrow(log_data)
nrow(net_data)
```

## (c)

First check that location data is distinct on ID column:

```{r}
nrow(loc_data |> 
        select(ID) |>
        distinct()) == nrow(loc_data)
```

286700/292786 rows remain after joining for log data.

```{r}
log_data_loc <- merge(log_data, loc_data, by.x="nodeid", by.y="ID")
nrow(log_data)
nrow(log_data_loc)
```

110433/110718 rows remain after joining for net data.

```{r}
net_data_loc <- merge(net_data, loc_data, by.x="nodeid", by.y="ID")
nrow(net_data)
nrow(net_data_loc)
```

## (d)

```{r}
log_data_five_num <- fivenum(log_data_loc[["voltage"]])
names(log_data_five_num) <- c("min", "Q1", "median", "Q3", "max")
log_data_five_num["Q1"]
```

Some of the histograms of the raw data together with Q1/median/Q3 without handling outliers:

```{r}
# par(mfcol = c(2, 5))
for (var in variables) {
  log_data_five_num <- fivenum(log_data_loc[[var]])
  names(log_data_five_num) <- c("min", "Q1", "median", "Q3", "max")
  plot1 <- ggplot(data = log_data_loc, aes_string(x = var)) +
           geom_histogram(na.rm = T, bins = 50) +
           geom_vline(xintercept = log_data_five_num["Q1"], linetype="dotted", color = "red") +
           geom_vline(xintercept = log_data_five_num["median"], linetype="dotted", color = "red") + 
           geom_vline(xintercept = log_data_five_num["Q3"], linetype="dotted", color = "red")
  
  net_data_five_num <- fivenum(net_data_loc[[var]])
  names(net_data_five_num) <- c("min", "Q1", "median", "Q3", "max")
  plot2 <- ggplot(data = net_data_loc, aes_string(x = var)) +
           geom_histogram(na.rm = T, bins = 50) +
           geom_vline(xintercept = net_data_five_num["Q1"], linetype="dotted", color = "red") +
           geom_vline(xintercept = net_data_five_num["median"], linetype="dotted", color = "red") + 
           geom_vline(xintercept = net_data_five_num["Q3"], linetype="dotted", color = "red")
  
  # print(plot1)
  # print(plot2)
  grid.arrange(plot1, plot2, nrow = 2)
  # plot3 <- grid.arrange(plot1, plot2, ncol = 2)
  # print(plot3)
}
```

The takeaways are that:
1. histograms are perfect tools for identifying existence of outliers.
2. No essential information can be drawn from histograms unless the outliers are handled properly.

One possible solution is to use 1.5 x IQR Rule.

```{r}
for (var in variables) {
  five_num <- fivenum(log_data_loc[[var]])
  Q1 <- five_num[2]
  Q3 <- five_num[4]
  IQR <- Q3 - Q1
  log_data_loc_clean <- log_data_loc |>
                          filter(!!as.symbol(var) >= Q1-1.5*IQR, !!as.symbol(var) <= Q3+1.5*IQR)
  five_num <- fivenum(log_data_loc_clean[[var]])
  Q1 <- five_num[2]
  median <- five_num[3]
  Q3 <- five_num[4]
  plot1 <- ggplot(data = log_data_loc_clean, aes_string(x = var)) +
           geom_histogram(na.rm = T, bins = 50) +
           geom_vline(xintercept = Q1, linetype = "dotted", color = "red") +
           geom_vline(xintercept = median, linetype = "dotted", color = "red") + 
           geom_vline(xintercept = Q3, linetype = "dotted", color = "red")
  
  five_num <- fivenum(net_data_loc[[var]])
  Q1 <- five_num[2]
  Q3 <- five_num[4]
  IQR <- Q3 - Q1
  net_data_loc_clean <- net_data_loc |>
                          filter(!!as.symbol(var) >= Q1-1.5*IQR, !!as.symbol(var) <= Q3+1.5*IQR)
  five_num <- fivenum(net_data_loc_clean[[var]])
  Q1 <- five_num[2]
  median <- five_num[3]
  Q3 <- five_num[4]
  plot2 <- ggplot(data = net_data_loc_clean, aes_string(x = var)) +
           geom_histogram(na.rm = T, bins = 50) +
           geom_vline(xintercept = Q1, linetype = "dotted", color = "red") +
           geom_vline(xintercept = median, linetype = "dotted", color = "red") + 
           geom_vline(xintercept = Q3, linetype = "dotted", color = "red")
  
  grid.arrange(plot1, plot2, nrow = 2)
}
```

This turns out to fail, some evidence:
1. For humidity in log data, values smaller than 0 and larger than 100 are not fully removed.
2. For hamabot in both log and net data, only values of 0 are kept because both Q1 and Q3 are 0.
Therefore, quantile-based outlier rejection is not working.

Second possible solution is to use hard-coded values. But it is very hard to determine the threshold for hamatop and hamabot: Values tend to spread out equally and evenly within reasonable ranges without sudden drop. The absence of sudden drop makes it hard to determine the proper threshold.

```{r}
# Variable voltage
plot1 <- log_data_loc |>
           filter(voltage >= 2) |>
           ggplot(aes(x = voltage)) +
           geom_histogram(na.rm = T, bins = 50)

plot2 <- net_data_loc |>
           filter(voltage >= 2) |>
           ggplot(aes(x = voltage)) +
           geom_histogram(na.rm = T, bins = 50)

grid.arrange(plot1, plot2, ncol = 2)
```

```{r}
# Variable humidity
plot1 <- log_data_loc |>
           filter(humidity >= 0, humidity <= 100) |>
           ggplot(aes(x = humidity)) +
           geom_histogram(na.rm = T, bins = 50)

plot2 <- net_data_loc |> 
           filter(humidity >= 0, humidity <= 100) |>
           ggplot(aes(x = humidity)) +
           geom_histogram(na.rm = T, bins = 50)

grid.arrange(plot1, plot2, ncol = 2)
```

```{r}
# Variable temperature
plot1 <- log_data_loc |>
           filter(humid_temp >= 0, humid_temp <= 40) |>
           ggplot(aes(x = humid_temp)) +
           geom_histogram(na.rm = T, bins = 50)

plot2 <- net_data_loc |> 
           filter(humid_temp >= 0, humid_temp <= 40) |>
           ggplot(aes(x = humid_temp)) +
           geom_histogram(na.rm = T, bins = 50)

grid.arrange(plot1, plot2, ncol = 2)
```

```{r}
# Variable hamatop
plot1 <- log_data_loc |>
           filter(hamatop <= 15000) |>
           ggplot(aes(x = hamatop)) +
           geom_histogram(na.rm = T, bins = 50)

plot2 <- net_data_loc |> 
           filter(hamatop <= 15000) |>
           ggplot(aes(x = hamatop)) +
           geom_histogram(na.rm = T, bins = 50)

grid.arrange(plot1, plot2, ncol = 2)
```

```{r}
# Variable hamabot
plot1 <- log_data_loc |>
           filter(hamabot <= 5000) |>
           ggplot(aes(x = hamabot)) +
           geom_histogram(na.rm = T, bins = 50)

plot2 <- net_data_loc |> 
           filter(hamabot <= 5000) |>
           ggplot(aes(x = hamabot)) +
           geom_histogram(na.rm = T, bins = 50)

grid.arrange(plot1, plot2, ncol = 2)
```

Examine the battery voltage when there are known anomalies:

```{r}
log_data_loc |>
  filter(humidity < 0 | humidity > 100 | humid_temp < 0 | humid_temp > 40 | hamatop > 15000 | hamabot > 5000) |>
  select(voltage) |>
  ggplot(aes(x = voltage)) +
  geom_histogram(bins = 50)
```

```{r}
net_data_loc |>
  filter(humidity < 0 | humidity > 100 | humid_temp < 0 | humid_temp > 40 | hamatop > 15000 | hamabot > 5000) |>
  select(voltage) |>
  ggplot(aes(x = voltage)) +
  geom_histogram(bins = 50)
```


It looks extremely abnormal. To confirm the guess, draw the histogram when readings are reasonable:

```{r}
log_data_loc |>
  filter(humidity >= 0, humidity <= 100, humid_temp >= 0, humid_temp <= 40, hamatop <= 15000, hamabot <= 5000) |>
  select(voltage) |>
  ggplot(aes(x = voltage)) +
  geom_histogram(bins = 50)
```

```{r}
log_data_loc |>
  filter(humidity >= 0, humidity <= 100, humid_temp >= 0, humid_temp <= 40, hamatop <= 2000, hamabot <= 200) |>
  select(voltage) |>
  ggplot(aes(x = voltage)) +
  geom_histogram(bins = 50)
```

Voltage still looks abnormal..........

```{r}
nrow(loc_data)
nrow(log_data_loc |> 
       select(nodeid) |>
       distinct())
nrow(net_data_loc |> 
       select(nodeid) |>
       distinct())
```

```{r}
log_data_loc |>
  mutate(abnormal = case_when(humid_temp >= 40 ~ 1,
                              TRUE ~ 0)) |>
  dplyr::count(nodeid, abnormal)
```

Conclusion: not too many abnormal readings.

```{r}
net_data_loc |>
  mutate(abnormal = case_when(humid_temp >= 40 ~ 1,
                              TRUE ~ 0)) |>
  dplyr::count(nodeid, abnormal)
```

Selected nodeid from net_data: 3/78/123/141/145

```{r}
net_data_loc |>
  filter(nodeid == 78 | nodeid == 123 | nodeid == 145 | nodeid == 3 | nodeid == 141) |>
  mutate(nodeid = as.character(nodeid)) |>
  ggplot(aes(x = result_time, y = humid_temp)) +
  geom_line(aes(colour = nodeid))
```

```{r}
net_data_loc |>
  filter(nodeid == 78 | nodeid == 123 | nodeid == 145 | nodeid == 3 | nodeid == 141) |>
  mutate(nodeid = as.character(nodeid)) |>
  ggplot(aes(x = result_time, y = voltage)) +
  geom_line(aes(colour = nodeid))
```

Node 123/3/78 demonstrate the correlation mentioned in the thesis. Node 141 and 145 have problematic reading for voltage throughout the experiment. It's valid to drop readings with very low voltage.

```{r}
log_data_loc |>
  mutate(abnormal = case_when(humidity >= 100 | humidity <= 0 ~ 1,
                              TRUE ~ 0)) |>
  dplyr::count(nodeid, abnormal) |>
  filter(abnormal == 1) |>
  select(nodeid, n) |>
  arrange(desc(n))
```

```{r}
nodeid_log_hum <- log_data_loc |>
                    mutate(abnormal = case_when(humidity >= 100 | humidity <= 0 ~ 1,
                                                TRUE ~ 0)) |>
                    dplyr::count(nodeid, abnormal) |>
                    filter(abnormal == 1, n >= 1000) |>
                    select(nodeid) |>
                    distinct()
```

```{r}
plot1 <- merge(log_data_loc, nodeid_log_hum, by = "nodeid") |>
  mutate(nodeid = as.character(nodeid)) |>
  ggplot(aes(x = epoch, y = humidity)) +
  geom_line(aes(colour = nodeid))

plot2 <- merge(log_data_loc, nodeid_log_hum, by = "nodeid") |>
  mutate(nodeid = as.character(nodeid)) |>
  ggplot(aes(x = epoch, y = voltage)) +
  geom_line(aes(colour = nodeid))

grid.arrange(plot1, plot2, nrow = 2)
```

```{r}
nodeid_log_hum <- log_data_loc |>
                    mutate(abnormal = case_when(humidity >= 100 | humidity <= 0 ~ 1,
                                                TRUE ~ 0)) |>
                    dplyr::count(nodeid, abnormal) |>
                    filter(abnormal == 1, n >= 900, n <= 1000) |>
                    select(nodeid) |>
                    distinct()
```

```{r}
plot1 <- merge(log_data_loc, nodeid_log_hum, by = "nodeid") |>
  mutate(nodeid = as.character(nodeid)) |>
  ggplot(aes(x = epoch, y = humidity)) +
  geom_line(aes(colour = nodeid))

plot2 <- merge(log_data_loc, nodeid_log_hum, by = "nodeid") |>
  mutate(nodeid = as.character(nodeid)) |>
  ggplot(aes(x = epoch, y = voltage)) +
  geom_line(aes(colour = nodeid))

grid.arrange(plot1, plot2, nrow = 2)
```

```{r}
net_data_loc |>
  mutate(abnormal = case_when(humidity >= 100 | humidity <= 0 ~ 1,
                              TRUE ~ 0)) |>
  dplyr::count(nodeid, abnormal) |>
  filter(abnormal == 1) |>
  select(nodeid, n) |>
  arrange(desc(n))
```

```{r}
nodeid_net_hum <- net_data_loc |>
                    mutate(abnormal = case_when(humidity >= 100 | humidity <= 0 ~ 1,
                                                TRUE ~ 0)) |>
                    dplyr::count(nodeid, abnormal) |>
                    filter(abnormal == 1, n >= 1000) |>
                    select(nodeid) |>
                    distinct()

plot1 <- merge(net_data_loc, nodeid_net_hum, by = "nodeid") |>
  mutate(nodeid = as.character(nodeid)) |>
  ggplot(aes(x = epoch, y = humidity)) +
  geom_line(aes(colour = nodeid))

plot2 <- merge(net_data_loc, nodeid_net_hum, by = "nodeid") |>
  mutate(nodeid = as.character(nodeid)) |>
  ggplot(aes(x = epoch, y = voltage)) +
  geom_line(aes(colour = nodeid))

grid.arrange(plot1, plot2, nrow = 2)
```

Conclusion: there's no correlation between abnormal humidity reading and voltage reading for both datasets. Nodes tend to have similar trend. Therefore, those readings above 100 should be considered not accurate enough but they exhibit valid trend. Moreover, datasets have similar summary statistics. So we'll only consider net data for rest of the variables.

```{r}
net_data_loc |>
  mutate(abnormal = case_when(hamatop >= 15000 ~ 1,
                              TRUE ~ 0)) |>
  group_by(nodeid, Height, abnormal) |>
  dplyr::summarise(n = n(), .groups = "drop") |>
  filter(abnormal == 1) |>
  select(nodeid, n, Height) |>
  arrange(desc(n))
```

```{r}
nodeid_net_top <- net_data_loc |>
                    mutate(abnormal = case_when(hamatop >= 15000 ~ 1,
                                                TRUE ~ 0)) |>
                    dplyr::count(nodeid, abnormal) |>
                    filter(abnormal == 1, n >= 1400) |>
                    select(nodeid) |>
                    distinct()

plot1 <- merge(net_data_loc, nodeid_net_top, by = "nodeid") |>
  mutate(nodeid = as.character(nodeid)) |>
  ggplot(aes(x = epoch, y = hamatop)) +
  geom_line(aes(colour = nodeid))

plot2 <- merge(net_data_loc, nodeid_net_top, by = "nodeid") |>
  mutate(nodeid = as.character(nodeid)) |>
  ggplot(aes(x = epoch, y = voltage)) +
  geom_line(aes(colour = nodeid))

grid.arrange(plot1, plot2, nrow = 2)
```

```{r}
nodeid_net_top <- net_data_loc |>
                    mutate(abnormal = case_when(hamatop >= 15000 ~ 1,
                                                TRUE ~ 0)) |>
                    dplyr::count(nodeid, abnormal) |>
                    filter(abnormal == 1, n >= 1300, n <= 1400) |>
                    select(nodeid) |>
                    distinct()

plot1 <- merge(net_data_loc, nodeid_net_top, by = "nodeid") |>
  mutate(nodeid = as.character(nodeid)) |>
  ggplot(aes(x = epoch, y = hamatop)) +
  geom_line(aes(colour = nodeid))

plot2 <- merge(net_data_loc, nodeid_net_top, by = "nodeid") |>
  mutate(nodeid = as.character(nodeid)) |>
  ggplot(aes(x = epoch, y = voltage)) +
  geom_line(aes(colour = nodeid))

grid.arrange(plot1, plot2, nrow = 2)
```

```{r}
nodeid_net_top <- net_data_loc |>
                    mutate(abnormal = case_when(hamatop >= 15000 ~ 1,
                                                TRUE ~ 0)) |>
                    dplyr::count(nodeid, abnormal) |>
                    filter(abnormal == 1, n >= 1000, n <= 1300) |>
                    select(nodeid) |>
                    distinct()

plot1 <- merge(net_data_loc, nodeid_net_top, by = "nodeid") |>
  mutate(nodeid = as.character(nodeid)) |>
  ggplot(aes(x = epoch, y = hamatop)) +
  geom_line(aes(colour = nodeid))

plot2 <- merge(net_data_loc, nodeid_net_top, by = "nodeid") |>
  mutate(nodeid = as.character(nodeid)) |>
  ggplot(aes(x = epoch, y = voltage)) +
  geom_line(aes(colour = nodeid))

grid.arrange(plot1, plot2, nrow = 2)
```

The conclusion is that those very high readings are valid. They indeed reflects the actual incident light intensity. What's interesting is to notice that the node 138 in the last graph matches with the voltage correlation. The readings are gone after observing very low voltage.

```{r}
net_data_loc |>
  mutate(abnormal = case_when(hamabot >= 4000 ~ 1,
                              TRUE ~ 0)) |>
  group_by(nodeid, Height, abnormal) |>
  dplyr::summarise(n = n(), .groups = "drop") |>
  filter(abnormal == 1) |>
  select(nodeid, n, Height) |>
  arrange(desc(n))
```

```{r}
nodeid_net_bottom <- net_data_loc |>
                    mutate(abnormal = case_when(hamabot >= 4000 ~ 1,
                                                TRUE ~ 0)) |>
                    dplyr::count(nodeid, abnormal) |>
                    filter(abnormal == 1, n >= 300) |>
                    select(nodeid) |>
                    distinct()

plot1 <- merge(net_data_loc, nodeid_net_bottom, by = "nodeid") |>
  mutate(nodeid = as.character(nodeid)) |>
  ggplot(aes(x = epoch, y = hamabot)) +
  geom_line(aes(colour = nodeid))

plot2 <- merge(net_data_loc, nodeid_net_bottom, by = "nodeid") |>
  mutate(nodeid = as.character(nodeid)) |>
  ggplot(aes(x = epoch, y = voltage)) +
  geom_line(aes(colour = nodeid))

grid.arrange(plot1, plot2, nrow = 2)
```

All 3 nodes exhibit same trend: they tend to reach peak at the same time. The conclusion is that the bottom readings are valid as well. 

All we need to do is to remove the readings that are absolutely wrong (way off) for humidity/hamatop/hamabot.


## Part 3: Data Exploration

```{r}
# net_data_loc <- net_data_loc %>%
  # rename(reflected = hamabot, incident = hamatop)
head(net_data_loc, 10)
```
```{r}
head(log_data_loc, 10)
```
(a)
```{r}
intersect <- inner_join(net_data_loc, log_data_loc, by = c("nodeid", "epoch"))
intersect <- select(intersect, -16:-28)
# pick time period
intersect$result_time.x <- as.POSIXct(strptime(intersect$result_time.x, 
                                               format = "%A %b %d %H:%M:%S %Y"))
intersect %>%
  select(nodeid, result_time.x, Height.x) %>%
  ggplot() +
  geom_point(aes(x = result_time.x, y = as.factor(nodeid), color = Height.x), size = 0.1) +
  labs(x = "Days", y = "nodeid") +
  geom_vline(xintercept = as.numeric(as.POSIXct(c("2004/05/07 11:25:00","2004/05/26 9:00:00")))) +
  annotate("text", x = as.POSIXct("2004/05/24 23:00:00"), y = 3, 
           label = "9:00 am, May 26", size = 4) +
  annotate("text", x = as.POSIXct("2005/05/09 9:00:00"), y = 3,
           label = "11:25 am, May 7", size = 4)
```

```{r}
library(GGally)
ggpairs(select(net_data_loc, humidity, humid_temp, hamatop, hamabot, Height))
```

```{r}
fig1 <- net_data_loc %>%
  filter(as.POSIXct(result_time) < '2004-05-15') %>%
  ggplot(aes(x = hamatop, y = hamabot)) +
  geom_point() +
  geom_smooth(formula = y ~ x, method = "lm", se = FALSE) +
  labs(title = "", x = "Incident PAR", y = "Reflected PAR") +
  theme_bw()

fig2 <- net_data_loc %>%
  filter(as.POSIXct(result_time) < '2004-05-15') %>%
  ggplot(aes(x = humid_temp, y = humidity)) +
  geom_point() +
  geom_smooth(formula = y ~ x, method = "lm", se = FALSE) +
  labs(title = "", x = "Temperature", y = "Relative Humidity") +
  theme_bw()

grid.arrange(fig1, fig2, ncol = 2)

```

```{r}
fig3 <- net_data_loc %>%
  filter(as.POSIXct(result_time) < '2004-06-03') %>%
  ggplot(aes(x = hamatop, y = Height)) +
  geom_point() +
  geom_smooth(formula = y ~ x, method = "lm", se = FALSE) +
  labs(title = "", x = "Incident PAR", y = "Node Height") +
  theme_bw()
grid.arrange(fig3, ncol = 1)
```


```{r fig.width=15, fig.height=8}
library(lubridate)

temp_plot <- net_data_loc %>%
  filter(date(result_time) < '2004-06-02') %>%
  group_by(date = date(result_time), Height) %>%
  summarise(across(humid_temp, mean), .groups = "drop") %>%
  ggplot(aes(x = date, y = humid_temp, color = Height, group = Height)) +
  geom_line() +
  scale_x_date(date_breaks = "3 days", limits = c(as_date("2004-05-07"), as_date("2004-06-02")), expand = c(0,0), date_labels = "%B %d") +
  scale_color_gradient(low = "orange", high = "blue") +
  labs(title = "Temperature", x = "", y = "", color = "Node Height") +
  theme_bw()

humidity_plot <- net_data_loc %>%
  filter(date(result_time) < '2004-06-02') %>%
  group_by(date = date(result_time), Height) %>%
  summarise(across(humidity, mean), .groups = "drop") %>%
  ggplot(aes(x = date, y = humidity, color = Height, group = Height)) +
  geom_line() +
  scale_x_date(date_breaks = "3 days", limits = c(as_date("2004-05-07"), as_date("2004-06-02")), expand = c(0,0), date_labels = "%B %d") +
  scale_color_gradient(low = "orange", high = "blue") +
  labs(title = "Relative Humidity", x = "", y = "", color = "Node Height") +
  theme_bw()

incident_plot <- net_data_loc %>%
  filter(date(result_time) < '2004-06-02') %>%
  group_by(date = date(result_time), Height) %>%
  summarise(across(hamatop, mean), .groups = "drop") %>%
  ggplot(aes(x = date, y = hamatop, color = Height, group = Height)) +
  geom_line() +
  scale_x_date(date_breaks = "3 days", limits = c(as_date("2004-05-07"), as_date("2004-06-02")), expand = c(0,0), date_labels = "%B %d") +
  scale_color_gradient(low = "orange", high = "blue") +
  labs(title = "Incident PAR", x = "", y = "", color = "Node Height") +
  theme_bw()

reflected_plot <- net_data_loc %>%
  filter(date(result_time) < '2004-06-02') %>%
  group_by(date = date(result_time), Height) %>%
  summarise(across(hamabot, mean), .groups = "drop") %>%
  ggplot(aes(x = date, y = hamabot, color = Height, group = Height)) +
  geom_line() +
  scale_x_date(date_breaks = "3 days", limits = c(as_date("2004-05-07"), as_date("2004-06-02")), expand = c(0,0), date_labels = "%B %d") +
  scale_color_gradient(low = "orange", high = "blue") +
  labs(title = "Reflected PAR", x = "", y = "", color = "Node Height") +
  theme_bw()

grid.arrange(temp_plot, humidity_plot, incident_plot, reflected_plot, ncol = 2, nrow = 2)
```

(d) PCA: 
```{r}
pca <- net_data_loc %>%
  select(humidity, humid_temp, hamatop, hamabot) %>% 
  prcomp(center = TRUE, scale = TRUE)
# screeplot
pca$sdev^2 %>%
  data.frame(PC = c(1:4), Eigenvalue = .) %>%
  ggplot(., aes(x = PC, y = Eigenvalue)) +
  geom_point() +
  geom_line()
```

## Part 4: Interesting findings

```{r}
# KMeans
height <- net_data_loc %>%
  group_by(Height) %>%
  summarise(across(c(humidity, humid_temp), mean))

set.seed(2022)
cluster <- height %>%
  select(-Height) %>%
  kmeans(centers = 2, nstart = 10)

height %>%
  mutate(cluster = factor(cluster$cluster)) %>%
  ggplot(aes(x = Height, fill = cluster, group = cluster)) +
  geom_density(alpha = 0.7, color = FALSE) +
  labs(title = "", x = "Height (m)", y = "", fill = "Cluster") +
  scale_fill_viridis_d() +
  theme_bw()
```


```{r}
# GMM
library(mixtools)
df <- net_data_loc[as_date(net_data_loc$result_time) == "2004-05-07",]
em <- mvnormalmixEM(df[, c("humidity", "humid_temp")])
plot(em, whichplots = 2)
```

```{r}
df$gmm_group_1 <- em$posterior[, 1] > 0.5 # T for group 1, F for group 2
df %>%
  ggplot() +
  geom_point(aes(x = humidity, y = humid_temp, group = gmm_group_1, color = gmm_group_1))
df %>%
  ggplot() +
  geom_point(aes(x = Height, y = result_time, group = gmm_group_1, color = gmm_group_1))
```

```{r}
# PCA
pca
autoplot(pca, col = "hamabot", label = FALSE, loadings.label = TRUE) +
  theme_classic()
```

```{r}
# HC
library(cluster)
net_data_loc = cbind(net_data_loc, data.matrix(pca$x)[, c(1, 2)])
df1 <- net_data_loc[as_date(net_data_loc$result_time) == "2004-05-07", c("PC1", "PC2")]
m <- c("average", "single", "complete", "ward")
names(m) <- c("average", "single", "complete", "ward")
agg_coeff <- function(x){
  agnes(df1, method = x)$ac
}
result <- sapply(m, agg_coeff)
result # ward has the highest agglomerative coeff
```

```{r}
cluster <- df1 %>%
  agnes(method = "ward")
pltree(cluster, cex = 0.6, hang = -1, main = "Dendogram") # plot the tree
# apply gap statistic to compare total intra-cluster variation
gap_stat <- clusGap(df1, FUN = hcut, nstart = 25, K.max = 10, B = 50)
# choose k with the highest gap statistic
fviz_gap_stat(gap_stat)
```

```{r}
final_clust <- hclust(dist(df1, method = "euclidean"), method = "ward.D2")
agnes_group <- cutree(final_clust, k = 5)
df1 <- data.frame(cbind(net_data_loc[as_date(net_data_loc$result_time) == "2004-05-07", ], agnes_group = as.factor(agnes_group)))
df1 %>% 
  ggplot() +
  geom_point(aes(result_time, Height, group = agnes_group, color = agnes_group), alpha = 0.5)
df1[df1$agnes_group == 4|df1$agnes_group == 5, ] %>%
  ggplot() +
  geom_point(aes(humid_temp, humidity, group = agnes_group, color = agnes_group), alpha = 0.5)
```

```{r}
df1[df1$agnes_group == 4 & df1$humid_temp < 11 & df1$humidity > 95, ]$hamabot
df1[df1$agnes_group == 4 & df1$humid_temp < 11 & df1$humidity > 95, ]$hamatop
# doesn't have low temperature and humidity
# low_temp & high humidity in 4: hamabot all between 20-40; hamatop all 0
unique(df1[df1$agnes_group == 4, ]$Direc)
unique(df1[df1$agnes_group == 5, ]$Direc)
```